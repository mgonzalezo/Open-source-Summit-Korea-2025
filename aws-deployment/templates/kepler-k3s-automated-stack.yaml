AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation stack for Kepler on bare-metal EC2 with K3s - Fully Automated with RAPL (Direct Hardware Measurements)'

Parameters:
  InstanceType:
    Description: EC2 instance type (bare-metal)
    Type: String
    Default: c5.metal
    AllowedValues:
      - c5.metal
      - m5.metal
      - m5d.metal
      - r5.metal
    ConstraintDescription: Must be a valid bare-metal instance type

  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: Must be the name of an existing EC2 KeyPair

  SSHLocation:
    Description: IP address range that can SSH to the EC2 instance
    Type: String
    Default: 0.0.0.0/0
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    ConstraintDescription: Must be a valid IP CIDR range of the form x.x.x.x/x

  VolumeSize:
    Description: EBS Volume size in GB
    Type: Number
    Default: 100
    MinValue: 50
    MaxValue: 500

  VpcId:
    Description: VPC ID for security group
    Type: AWS::EC2::VPC::Id
    ConstraintDescription: Must be a valid VPC ID

  AutoInstallKepler:
    Description: Automatically install Kepler with RAPL on boot
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Instance Configuration"
        Parameters:
          - InstanceType
          - KeyName
          - VolumeSize
          - AutoInstallKepler
      - Label:
          default: "Network Configuration"
        Parameters:
          - VpcId
          - SSHLocation

Resources:
  # Security Group with all required ports
  KeplerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: kepler-k3s-security-group
      GroupDescription: Security group for Kepler K3s cluster with RAPL
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref SSHLocation
          Description: SSH access
        - IpProtocol: tcp
          FromPort: 6443
          ToPort: 6443
          CidrIp: !Ref SSHLocation
          Description: Kubernetes API Server
        - IpProtocol: tcp
          FromPort: 30080
          ToPort: 30080
          CidrIp: 0.0.0.0/0
          Description: Kepler HTTP Metrics
        - IpProtocol: tcp
          FromPort: 30443
          ToPort: 30443
          CidrIp: 0.0.0.0/0
          Description: Kepler HTTPS Metrics (NodePort)
        - IpProtocol: tcp
          FromPort: 30800
          ToPort: 30800
          CidrIp: 0.0.0.0/0
          Description: MCP Server (SSE)
        - IpProtocol: tcp
          FromPort: 28282
          ToPort: 28282
          CidrIp: !Ref SSHLocation
          Description: Kepler Internal Metrics
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: kepler-k3s-sg
        - Key: Project
          Value: Kepler-OSS-Korea-2025

  # IAM Role for EC2
  KeplerEC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: kepler-k3s-ec2-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags:
        - Key: Name
          Value: kepler-k3s-ec2-role
        - Key: Project
          Value: Kepler-OSS-Korea-2025

  KeplerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: kepler-k3s-instance-profile
      Roles:
        - !Ref KeplerEC2Role

  # EC2 Instance with automated Kepler setup
  KeplerBareMetalInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !Sub '{{resolve:ssm:/aws/service/canonical/ubuntu/server/24.04/stable/current/amd64/hvm/ebs-gp3/ami-id}}'
      KeyName: !Ref KeyName
      IamInstanceProfile: !Ref KeplerInstanceProfile
      SecurityGroupIds:
        - !Ref KeplerSecurityGroup
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: !Ref VolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e

          # Log all output
          exec > >(tee /var/log/user-data.log)
          exec 2>&1

          echo "========================================="
          echo "Starting Kepler K3s Setup"
          echo "Time: $(date)"
          echo "========================================="

          # Update system
          echo "Updating system..."
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get upgrade -y

          # Install dependencies
          echo "Installing dependencies..."
          apt-get install -y \
              curl \
              wget \
              git \
              jq \
              unzip \
              make \
              msr-tools \
              linux-tools-common \
              linux-tools-generic

          # Enable RAPL for direct hardware power measurements
          echo "Enabling RAPL (Running Average Power Limit)..."
          apt-get install -y linux-modules-$(uname -r) linux-modules-extra-$(uname -r)

          # Load RAPL modules
          modprobe msr
          modprobe intel_rapl_common
          modprobe intel_rapl_msr

          # Make modules load on boot
          echo "msr" >> /etc/modules
          echo "intel_rapl_common" >> /etc/modules
          echo "intel_rapl_msr" >> /etc/modules

          # Verify RAPL is working
          echo "Verifying RAPL..."
          if [ -d "/sys/class/powercap/intel-rapl:0" ]; then
            echo "✅ RAPL enabled successfully"
            ls -la /sys/class/powercap/ | grep intel-rapl
          else
            echo "⚠️ RAPL zones not found, will fall back to model-based estimation"
          fi

          # Install Docker for MCP server image builds
          echo "Installing Docker..."
          apt-get install -y docker.io
          systemctl start docker
          systemctl enable docker
          usermod -aG docker ubuntu
          echo "Docker installed: $(docker --version)"

          # Install K3s
          echo "Installing K3s..."
          curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="server --disable traefik" sh -

          # Wait for K3s to be ready
          echo "Waiting for K3s to be ready..."
          sleep 30
          until kubectl get nodes 2>/dev/null; do
            echo "Waiting for K3s..."
            sleep 5
          done

          # Setup kubectl for ubuntu user
          mkdir -p /home/ubuntu/.kube
          cp /etc/rancher/k3s/k3s.yaml /home/ubuntu/.kube/config
          chown -R ubuntu:ubuntu /home/ubuntu/.kube
          chmod 600 /home/ubuntu/.kube/config

          # Install Helm
          echo "Installing Helm..."
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

          # Install kustomize
          echo "Installing kustomize..."
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          mv kustomize /usr/local/bin/

          # Create automated Kepler setup script with RAPL
          cat > /home/ubuntu/setup-kepler-automated.sh << 'EOFSETUP'
          #!/bin/bash
          set -e

          echo "========================================="
          echo "Automated Kepler + RAPL Setup"
          echo "========================================="

          export KUBECONFIG=/etc/rancher/k3s/k3s.yaml

          # Wait for K3s
          echo "Waiting for K3s to be fully ready..."
          kubectl wait --for=condition=ready node --all --timeout=300s

          # Download Kepler v0.11.2 Helm chart
          echo "Downloading Kepler v0.11.2..."
          cd /home/ubuntu
          wget -q https://github.com/sustainable-computing-io/kepler/archive/refs/tags/v0.11.2.tar.gz
          tar -xzf v0.11.2.tar.gz

          # Create Helm values for Kepler with RAPL (direct hardware measurements)
          cat > /tmp/kepler-values.yaml << 'EOFVALUES'
          image:
            repository: quay.io/sustainable_computing_io/kepler
            pullPolicy: Always
            tag: v0.11.2

          config:
            log:
              level: info
              format: text
            host:
              sysfs: /host/sys
              procfs: /host/proc
            monitor:
              interval: 5s
              staleness: 500ms
              maxTerminated: 500
              minTerminatedEnergyThreshold: 10
            rapl:
              zones: []  # Empty = auto-detect RAPL zones
            exporter:
              stdout:
                enabled: false
              prometheus:
                enabled: true
                debugCollectors:
                  - go
                metricsLevel:
                  - node
                  - pod
                  - container
                  - process
            web:
              configFile: ""
              listenAddresses:
                - :28282
            debug:
              pprof:
                enabled: false
            kube:
              enabled: false
              config: ""
              nodeName: ""
            dev:
              fake-cpu-meter:
                enabled: false  # Disabled - using RAPL instead!
            model:
              enabled: false  # Disabled - using RAPL instead!

          daemonset:
            hostPID: true
            tolerations:
              - operator: Exists
            securityContext:
              privileged: true
            resources:
              limits:
                cpu: 1000m
                memory: 1Gi
              requests:
                cpu: 200m
                memory: 256Mi
            extraVolumes:
              - name: proc
                hostPath:
                  path: /proc
                  type: Directory
              - name: sys
                hostPath:
                  path: /sys
                  type: Directory
              - name: dev-cpu
                hostPath:
                  path: /dev/cpu
                  type: Directory
            extraVolumeMounts:
              - name: proc
                mountPath: /host/proc
                readOnly: true
              - name: sys
                mountPath: /host/sys
                readOnly: true
              - name: dev-cpu
                mountPath: /dev/cpu
                readOnly: true

          service:
            type: ClusterIP
            port: 28282
            targetPort: 28282

          rbac:
            create: true

          serviceAccount:
            create: true
            name: kepler
          EOFVALUES

          # Install Kepler via Helm
          echo "Installing Kepler v0.11.2 via Helm..."
          helm install kepler ./kepler-0.11.2/manifests/helm/kepler \
            --namespace kepler-system \
            --create-namespace \
            -f /tmp/kepler-values.yaml \
            --wait \
            --timeout 10m

          # RAPL is now enabled - Kepler will use direct hardware measurements
          echo "Kepler deployed with RAPL (direct hardware power measurements)"
          echo "No Model Server needed - using Intel RAPL zones"

          # Deploy HTTPS Proxy for Kepler metrics
          echo "Setting up HTTPS access for Kepler metrics..."

          # Generate self-signed certificate with OpenSSL
          echo "Generating self-signed TLS certificate..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /tmp/tls.key \
            -out /tmp/tls.crt \
            -subj "/CN=kepler.local/O=kepler" \
            -addext "subjectAltName=DNS:kepler.local,DNS:kepler.kepler-system.svc,DNS:kepler.kepler-system.svc.cluster.local"

          # Create Kubernetes secret with TLS certificate
          kubectl create secret tls kepler-tls-secret \
            --cert=/tmp/tls.crt \
            --key=/tmp/tls.key \
            -n kepler-system

          # Deploy HTTPS proxy
          cat > /tmp/kepler-https-proxy.yaml << 'EOFPROXY'
          ---
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: kepler-nginx-config
            namespace: kepler-system
          data:
            nginx.conf: |
              events {
                worker_connections 1024;
              }

              http {
                server {
                  listen 8443 ssl;
                  server_name _;

                  ssl_certificate /etc/nginx/ssl/tls.crt;
                  ssl_certificate_key /etc/nginx/ssl/tls.key;
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers HIGH:!aNULL:!MD5;

                  location / {
                    proxy_pass http://kepler.kepler-system.svc.cluster.local:28282;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                  }
                }
              }
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: kepler-https-proxy
            namespace: kepler-system
            labels:
              app: kepler-https-proxy
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: kepler-https-proxy
            template:
              metadata:
                labels:
                  app: kepler-https-proxy
              spec:
                containers:
                - name: nginx
                  image: nginx:alpine
                  ports:
                  - containerPort: 8443
                    name: https
                  volumeMounts:
                  - name: nginx-config
                    mountPath: /etc/nginx/nginx.conf
                    subPath: nginx.conf
                  - name: tls-cert
                    mountPath: /etc/nginx/ssl
                    readOnly: true
                volumes:
                - name: nginx-config
                  configMap:
                    name: kepler-nginx-config
                - name: tls-cert
                  secret:
                    secretName: kepler-tls-secret
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: kepler-https
            namespace: kepler-system
            labels:
              app: kepler-https-proxy
          spec:
            type: NodePort
            selector:
              app: kepler-https-proxy
            ports:
              - name: https
                port: 8443
                targetPort: 8443
                nodePort: 30443
                protocol: TCP
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: kepler-http
            namespace: kepler-system
          spec:
            type: NodePort
            selector:
              app.kubernetes.io/name: kepler
            ports:
              - name: http
                port: 28282
                targetPort: 28282
                nodePort: 30080
                protocol: TCP
          EOFPROXY

          kubectl apply -f /tmp/kepler-https-proxy.yaml

          # Wait for HTTPS proxy
          kubectl wait --for=condition=ready pod -l app=kepler-https-proxy -n kepler-system --timeout=300s

          # Deploy demo workloads for power consumption testing
          echo ""
          echo "========================================="
          echo "Deploying demo workloads for compliance testing..."
          echo "========================================="

          # Create demo-workloads namespace
          kubectl create namespace demo-workloads || true

          # Create demo workloads manifest inline
          cat > /tmp/demo-workloads.yaml << 'EOFDEMO'
          ---
          # High CPU workload - crypto mining simulation
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: crypto-miner-simulation
            namespace: demo-workloads
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: crypto-miner
            template:
              metadata:
                labels:
                  app: crypto-miner
                  power-profile: high
              spec:
                containers:
                - name: stress
                  image: polinux/stress
                  resources:
                    requests:
                      cpu: "500m"
                      memory: "256Mi"
                    limits:
                      cpu: "1000m"
                      memory: "512Mi"
                  command: ["stress"]
                  args: ["--cpu", "2", "--timeout", "0"]
          ---
          # High power CPU burner
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: high-power-cpu-burner
            namespace: demo-workloads
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: cpu-burner
            template:
              metadata:
                labels:
                  app: cpu-burner
                  power-profile: very-high
              spec:
                containers:
                - name: stress
                  image: polinux/stress
                  resources:
                    requests:
                      cpu: "800m"
                      memory: "512Mi"
                    limits:
                      cpu: "1500m"
                      memory: "1Gi"
                  command: ["stress"]
                  args: ["--cpu", "4", "--vm", "2", "--vm-bytes", "256M", "--timeout", "0"]
          ---
          # Memory intensive workload
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: memory-intensive-app
            namespace: demo-workloads
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: memory-app
            template:
              metadata:
                labels:
                  app: memory-app
                  power-profile: medium
              spec:
                containers:
                - name: stress
                  image: polinux/stress
                  resources:
                    requests:
                      cpu: "200m"
                      memory: "512Mi"
                    limits:
                      cpu: "500m"
                      memory: "1Gi"
                  command: ["stress"]
                  args: ["--vm", "4", "--vm-bytes", "200M", "--timeout", "0"]
          ---
          # Inefficient algorithm simulation
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: inefficient-fibonacci
            namespace: demo-workloads
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: fibonacci
            template:
              metadata:
                labels:
                  app: fibonacci
                  power-profile: medium-high
              spec:
                containers:
                - name: stress
                  image: polinux/stress
                  resources:
                    requests:
                      cpu: "400m"
                      memory: "256Mi"
                    limits:
                      cpu: "800m"
                      memory: "512Mi"
                  command: ["stress"]
                  args: ["--cpu", "3", "--timeout", "0"]
          ---
          # Low power idle workload
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: nginx-light
            namespace: demo-workloads
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: nginx-light
            template:
              metadata:
                labels:
                  app: nginx-light
                  power-profile: low
              spec:
                containers:
                - name: nginx
                  image: nginx:alpine
                  resources:
                    requests:
                      cpu: "50m"
                      memory: "64Mi"
                    limits:
                      cpu: "100m"
                      memory: "128Mi"
          EOFDEMO

          kubectl apply -f /tmp/demo-workloads.yaml
          echo "Demo workloads deployed in demo-workloads namespace"
          kubectl get pods -n demo-workloads -o wide

          # Build and deploy Carbon-Kepler MCP Server (without git clone)
          echo ""
          echo "========================================="
          echo "Building Carbon-Kepler MCP Server..."
          echo "========================================="

          # Create MCP server directory structure
          mkdir -p /home/ubuntu/carbon-kepler-mcp/src
          cd /home/ubuntu/carbon-kepler-mcp

          # Download MCP server source files directly from GitHub
          echo "Downloading MCP server source code..."
          MCP_REPO="https://raw.githubusercontent.com/marcosgonzalezo/Open-source-Summit-Korea-2025/main"

          # Download requirements.txt
          curl -sL "$MCP_REPO/carbon-kepler-mcp/requirements.txt" -o requirements.txt

          # Download Dockerfile
          curl -sL "$MCP_REPO/carbon-kepler-mcp/Dockerfile" -o Dockerfile

          # Download Python source files
          curl -sL "$MCP_REPO/carbon-kepler-mcp/src/__init__.py" -o src/__init__.py
          curl -sL "$MCP_REPO/carbon-kepler-mcp/src/mcp_server.py" -o src/mcp_server.py
          curl -sL "$MCP_REPO/carbon-kepler-mcp/src/kepler_client.py" -o src/kepler_client.py
          curl -sL "$MCP_REPO/carbon-kepler-mcp/src/carbon_calculator.py" -o src/carbon_calculator.py
          curl -sL "$MCP_REPO/carbon-kepler-mcp/src/power_hotspot_tools.py" -o src/power_hotspot_tools.py

          # Build Docker image
          echo "Building carbon-kepler-mcp Docker image..."
          docker build -t carbon-kepler-mcp:latest .

          # Import into K3s containerd
          echo "Importing image into K3s containerd..."
          docker save carbon-kepler-mcp:latest | k3s ctr images import -

          # Deploy MCP server with inline Kubernetes manifests
          echo ""
          echo "========================================="
          echo "Deploying MCP server to Kubernetes..."
          echo "========================================="

          # Create namespace
          kubectl create namespace carbon-mcp || true

          # Create ConfigMap
          cat > /tmp/mcp-configmap.yaml << 'EOFCM'
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: korea-compliance-data
            namespace: carbon-mcp
            labels:
              app: carbon-mcp-server
          data:
            carbon-intensity.json: |
              {
                "region": "ap-northeast-2",
                "region_name": "Seoul, Korea",
                "average_gCO2eq_kWh": 424,
                "grid_mix": {
                  "coal": 35,
                  "natural_gas": 28,
                  "nuclear": 25,
                  "renewable": 12
                },
                "cleanest_hours": [2, 3, 4],
                "dirtiest_hours": [12, 13, 14, 15, 16]
              }
            regulations.json: |
              {
                "korea_carbon_neutrality": {
                  "code": "KR_CARBON_2050",
                  "name": "Framework Act on Carbon Neutrality and Green Growth",
                  "name_local": "탄소중립 녹색성장 기본법",
                  "target_year": 2050,
                  "grid_carbon_intensity_gco2_kwh": 424
                },
                "korea_pue_standard": {
                  "code": "KR_PUE_GREEN_DC",
                  "name": "Energy Use Rationalization Act - Green Data Center",
                  "name_local": "에너지이용 합리화법 - 그린 데이터센터",
                  "target_pue": 1.4
                }
              }
            regions.json: |
              {
                "ap-northeast-2": {"average_gco2_kwh": 424, "region_name": "Seoul, Korea"},
                "us-east-1": {"average_gco2_kwh": 450, "region_name": "Virginia, USA"},
                "eu-north-1": {"average_gco2_kwh": 50, "region_name": "Stockholm, Sweden"}
              }
          EOFCM

          kubectl apply -f /tmp/mcp-configmap.yaml

          # Create RBAC
          cat > /tmp/mcp-rbac.yaml << 'EOFRBAC'
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: carbon-mcp-sa
            namespace: carbon-mcp
            labels:
              app: carbon-mcp-server
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRole
          metadata:
            name: carbon-mcp-cluster-reader
          rules:
          - apiGroups: [""]
            resources: ["pods", "namespaces", "nodes"]
            verbs: ["get", "list"]
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: carbon-mcp-cluster-reader-binding
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: carbon-mcp-cluster-reader
          subjects:
          - kind: ServiceAccount
            name: carbon-mcp-sa
            namespace: carbon-mcp
          EOFRBAC

          kubectl apply -f /tmp/mcp-rbac.yaml

          # Create Deployment
          cat > /tmp/mcp-deployment.yaml << 'EOFDEPLOY'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: carbon-mcp-server
            namespace: carbon-mcp
            labels:
              app: carbon-mcp-server
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: carbon-mcp-server
            template:
              metadata:
                labels:
                  app: carbon-mcp-server
              spec:
                serviceAccountName: carbon-mcp-sa
                containers:
                - name: mcp-server
                  image: docker.io/library/carbon-kepler-mcp:latest
                  imagePullPolicy: Never
                  ports:
                  - containerPort: 8000
                    name: http
                    protocol: TCP
                  env:
                  - name: KEPLER_ENDPOINT
                    value: "http://kepler.kepler-system.svc.cluster.local:28282/metrics"
                  - name: KOREA_CARBON_INTENSITY
                    value: "424"
                  - name: KOREA_PUE_TARGET
                    value: "1.4"
                  - name: PYTHONUNBUFFERED
                    value: "1"
                  - name: MCP_TRANSPORT
                    value: "sse"
                  - name: PORT
                    value: "8000"
                  resources:
                    requests:
                      cpu: 100m
                      memory: 128Mi
                    limits:
                      cpu: 500m
                      memory: 512Mi
                  volumeMounts:
                  - name: compliance-data
                    mountPath: /app/config
                    readOnly: true
                volumes:
                - name: compliance-data
                  configMap:
                    name: korea-compliance-data
          EOFDEPLOY

          kubectl apply -f /tmp/mcp-deployment.yaml

          # Create Service
          cat > /tmp/mcp-service.yaml << 'EOFSVC'
          apiVersion: v1
          kind: Service
          metadata:
            name: carbon-mcp-server
            namespace: carbon-mcp
            labels:
              app: carbon-mcp-server
          spec:
            type: NodePort
            selector:
              app: carbon-mcp-server
            ports:
            - name: http
              port: 8000
              targetPort: 8000
              nodePort: 30800
              protocol: TCP
          EOFSVC

          kubectl apply -f /tmp/mcp-service.yaml

          # Wait for MCP server to be ready
          echo "Waiting for MCP server to be ready..."
          kubectl wait --for=condition=ready pod -l app=carbon-mcp-server -n carbon-mcp --timeout=300s

          echo "MCP Server deployed successfully!"
          kubectl get pods -n carbon-mcp -o wide

          echo ""
          echo "========================================="
          echo "✅ Setup Complete!"
          echo "========================================="
          echo ""
          echo "Kepler Status:"
          kubectl get pods -n kepler-system
          echo ""
          echo "Demo Workloads:"
          kubectl get pods -n demo-workloads
          echo ""
          echo "MCP Server:"
          kubectl get pods -n carbon-mcp
          echo ""
          echo "RAPL Status:"
          echo "  Checking RAPL zones..."
          ls -la /sys/class/powercap/ | grep intel-rapl || echo "  ⚠️  RAPL zones not visible (check logs)"
          echo ""
          echo "Access Metrics:"
          INSTANCE_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
          echo "  HTTPS: curl -k https://$INSTANCE_IP:30443/metrics"
          echo "  HTTP:  curl http://$INSTANCE_IP:30080/metrics"
          echo "  MCP SSE: curl -N http://$INSTANCE_IP:30800/sse"
          echo ""
          echo "Deployment Summary saved to: /home/ubuntu/kepler-info.txt"

          # Save deployment info
          cat > /home/ubuntu/kepler-info.txt << EOFINFO
          Kepler + MCP Deployment Information for Open Source Summit Korea 2025
          ======================================================================

          Instance IP: $INSTANCE_IP

          Endpoints:
          ----------
          Kepler HTTPS Metrics: https://$INSTANCE_IP:30443/metrics
          Kepler HTTP Metrics:  http://$INSTANCE_IP:30080/metrics
          MCP SSE Endpoint:     http://$INSTANCE_IP:30800/sse

          Components Deployed:
          -------------------
          1. Kepler v0.11.2 (Power Measurement)
             - DaemonSet in kepler-system namespace
             - Intel RAPL (Direct Hardware Power Measurements)
             - HTTPS Proxy (Nginx with self-signed cert)

          2. Carbon-Kepler MCP Server
             - FastMCP 2.12.5 (SSE Transport)
             - Namespace: carbon-mcp
             - 8 tools for carbon-aware workload compliance
             - Korean Environmental Standards compliance checks

          3. Demo Workloads (demo-workloads namespace)
             - crypto-miner-simulation: High CPU workload (3 replicas)
             - high-power-cpu-burner: Very high power workload (2 replicas)
             - memory-intensive-app: Memory-heavy workload (2 replicas)
             - inefficient-fibonacci: Medium-high CPU workload (1 replica)
             - nginx-light: Low-power web server (2 replicas)

          Power Measurement Configuration:
          -------------------------------
          - Method: RAPL (Intel Running Average Power Limit)
          - RAPL Modules: msr, intel_rapl_common, intel_rapl_msr
          - RAPL Zones: Auto-detected (package + dram)
          - Metrics: procfs/sysfs CPU, memory, process tracking + RAPL energy
          - Collection Interval: 5 seconds

          Korean Environmental Standards:
          ------------------------------
          - 탄소중립 녹색성장 기본법: 424 gCO2eq/kWh
          - 에너지이용 합리화법: PUE ≤ 1.4

          Quick Access Commands:
          ---------------------
          # View all deployments
          kubectl get pods -A

          # Kepler metrics
          curl -k -s https://$INSTANCE_IP:30443/metrics | grep kepler_node_package_energy_joule

          # Demo workloads
          kubectl get pods -n demo-workloads -o wide

          # MCP Server
          kubectl get pods -n carbon-mcp
          kubectl logs -n carbon-mcp -l app=carbon-mcp-server

          # Test MCP SSE connection
          curl -N -H "Accept: text/event-stream" http://$INSTANCE_IP:30800/sse

          Verify RAPL Working:
          -------------------
          ls -la /sys/class/powercap/
          lsmod | grep rapl
          curl -k -s https://$INSTANCE_IP:30443/metrics | grep 'zone="package"'
          curl -k -s https://$INSTANCE_IP:30443/metrics | grep 'zone="dram"'

          Windows Claude Desktop Configuration:
          ------------------------------------
          1. Copy mcp-sse-bridge-windows.js to C:\\Users\\<username>\\
          2. Update claude_desktop_config.json:
          {
            "mcpServers": {
              "carbon-kepler": {
                "command": "node",
                "args": [
                  "C:\\\\Users\\\\<username>\\\\mcp-sse-bridge-windows.js",
                  "http://$INSTANCE_IP:30800/sse"
                ]
              }
            }
          }

          Deployment Notes:
          ----------------
          - MCP Server source downloaded directly from GitHub (no git clone needed)
          - MCP Server Code: /home/ubuntu/carbon-kepler-mcp/
          - Demo Workloads: Inline manifests (demo-workloads namespace)
          - All Kubernetes manifests embedded in CloudFormation template
          EOFINFO

          chown ubuntu:ubuntu /home/ubuntu/kepler-info.txt

          EOFSETUP

          chmod +x /home/ubuntu/setup-kepler-automated.sh
          chown ubuntu:ubuntu /home/ubuntu/setup-kepler-automated.sh

          # Create useful aliases
          cat > /home/ubuntu/.bash_aliases << 'EOFALIAS'
          alias k='kubectl'
          alias kgp='kubectl get pods -A'
          alias kgn='kubectl get nodes'
          alias klogs='kubectl logs -f'
          alias kdesc='kubectl describe'
          export KUBECONFIG=/home/ubuntu/.kube/config
          export PATH=$PATH:/usr/local/bin
          EOFALIAS

          chown ubuntu:ubuntu /home/ubuntu/.bash_aliases

          # Auto-install if enabled
          if [ "${AutoInstallKepler}" = "true" ]; then
            echo "Auto-installing Kepler..."
            sudo -u ubuntu bash /home/ubuntu/setup-kepler-automated.sh
          fi

          # Create completion marker
          echo "Setup completed at $(date)" > /var/log/user-data-complete.log
          echo "========================================="
          echo "User data script completed!"
          echo "========================================="
      Tags:
        - Key: Name
          Value: kepler-k3s-baremetal
        - Key: Project
          Value: Kepler-OSS-Korea-2025
        - Key: Purpose
          Value: Kepler-Demo-Automated

  # Elastic IP
  KeplerEIP:
    Type: AWS::EC2::EIP
    Properties:
      InstanceId: !Ref KeplerBareMetalInstance
      Tags:
        - Key: Name
          Value: kepler-k3s-eip
        - Key: Project
          Value: Kepler-OSS-Korea-2025

Outputs:
  InstanceId:
    Description: Instance ID of the bare-metal server
    Value: !Ref KeplerBareMetalInstance
    Export:
      Name: !Sub '${AWS::StackName}-InstanceId'

  PublicIP:
    Description: Public IP address of the server
    Value: !Ref KeplerEIP
    Export:
      Name: !Sub '${AWS::StackName}-PublicIP'

  SSHCommand:
    Description: SSH command to connect to the server
    Value: !Sub 'ssh -i ${KeyName}.pem ubuntu@${KeplerEIP}'

  HTTPSMetricsURL:
    Description: HTTPS URL for Kepler metrics (use -k flag with curl)
    Value: !Sub 'https://${KeplerEIP}:30443/metrics'

  HTTPMetricsURL:
    Description: HTTP URL for Kepler metrics
    Value: !Sub 'http://${KeplerEIP}:30080/metrics'

  MCPSSEEndpoint:
    Description: MCP SSE endpoint for Claude Desktop integration
    Value: !Sub 'http://${KeplerEIP}:30800/sse'

  TestCommand:
    Description: Test Kepler metrics endpoint
    Value: !Sub 'curl -k https://${KeplerEIP}:30443/metrics | grep kepler_node'

  MCPTestCommand:
    Description: Test MCP SSE connection
    Value: !Sub 'curl -N -H "Accept: text/event-stream" http://${KeplerEIP}:30800/sse'

  SetupStatus:
    Description: How to check setup status
    Value: !Sub |
      SSH Command: ssh -i ${KeyName}.pem ubuntu@${KeplerEIP}
      Check logs: tail -f /var/log/user-data.log
      Deployment info: cat /home/ubuntu/kepler-info.txt

  ComponentsDeployed:
    Description: List of deployed components
    Value: !Sub |
      ✅ Kepler v0.11.2 with RAPL (kepler-system namespace)
      ✅ Carbon-Kepler MCP Server with 8 tools (carbon-mcp namespace)
      ✅ Demo Workloads: 5 deployments with varying power profiles (demo-workloads namespace)

      MCP SSE Endpoint: http://${KeplerEIP}:30800/sse

      Windows Claude Desktop Config:
      {
        "mcpServers": {
          "carbon-kepler": {
            "command": "node",
            "args": ["C:\\Users\\<username>\\mcp-sse-bridge-windows.js", "http://${KeplerEIP}:30800/sse"]
          }
        }
      }

  InstanceType:
    Description: Instance type used
    Value: !Ref InstanceType

  SecurityGroupId:
    Description: Security Group ID
    Value: !Ref KeplerSecurityGroup
    Export:
      Name: !Sub '${AWS::StackName}-SecurityGroupId'

  CostEstimate:
    Description: Approximate hourly cost
    Value: !Sub 'Instance ${InstanceType} costs approximately $4.08/hour in us-east-1. Budget: $344.70 = ~84 hours'
